## 1.数据库是否使用读写分离和主从备份，都是怎么配置的
#### 主从备份
* 目标是将所有的写操作交由主数据库操作，在主数据库写入数据后要保证从数据库的数据也得到及时更新。
##### 配置步骤
* 配置主从库之间的关系
* 主库在执行sql之后将操作记录进入bin-log文件
* 从库读取主库的bin-log文件存于本地relay-log，然后从上次记住的位置开始执行sql
##### 存在问题
* 从库的数据更新是非实时的，可能存在数据不一致的问题
* 直接对从库的写操作可能会导致同步出错
#### 读写分离
* 读写分离是代码层次做的工作，将所有的写操作作用于主库上，把读操作作用于从库上
#### 参考链接
* https://blog.csdn.net/starlh35/article/details/78735510

## 2. spring中IOC容器的作用
#### 什么是Spring IOC
* IoC(Inversion of Control 控制反转) -- 什么反转：获得依赖对象的方式反转了
* 传统的方式：在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来
* SpringIoC，是由Spring容器容来控制、协调这些依赖对象的创建，而对象本身只需要关注业务逻辑的实现就可以了
* Spring容器：springIoC容器有两种，ApplicationContext和BeanFactory
    * ApplicationContext是BeanFactory的拓展，兼容BeanFactory的所有特性，面向的是spring框架
#### 参考链接
* [[Spring框架]Spring IOC的原理及详解](https://www.cnblogs.com/wang-meng/p/5597490.html)
* [Spring IOC核心源码学习](https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)

## 3. spring中的bean如何注入

## 4. hashmap如何扩容
#### JDK1.7
* 在jdk1.7之前，hashMap是用数组 + 链表实现的

#### JDK1.8
* jdk1.8中，hashMap是用数组 + 链表 + 红黑树实现的，当链表的长度 > 8，链表会被红黑树代替
    * [什么是红黑树](https://juejin.im/post/5a27c6946fb9a04509096248#comment)
* 如何扩容
    * 扩容必须满足两个条件：
        * 1、存放新值的时候当前已有元素的个数必须大于等于阈值
        * 2、存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）
    * 


```java
    /**
     * Initializes or doubles table size.  If null, allocates in
     * accord with initial capacity target held in field threshold.
     * Otherwise, because we are using power-of-two expansion, the
     * elements from each bin must either stay at same index, or move
     * with a power of two offset in the new table.
     *
     * @return the table
     */
    final Node<K,V>[] resize() {
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

## 5. 双亲委派模型
#### 什么是双亲委派模型
* 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
* 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
* 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
* 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。
#### 双亲委派模型的好处
* 类随着它的类加载器一起具备了一种带有优先级的层次关系。
#### 参考链接
* [浅谈双亲委派模型](https://www.imooc.com/article/34493)

## 6. synchronized和lock的区别
#### synchronized
*

#### lock
*

## 7. jvm崩溃的原因有哪些


## 8. jvm调优


## 9. Integer对象的比较有几种方法，分别是什么


## 10. 静态代码块的执行时机是什么


## 11. 非静态代码块的执行时机是什么


## 12. spring中多个事务中如何全部回滚


## 13. 生产环境中Linux服务器上都部署了什么


## 14. 使用了nginx哪些功能


## 15. nginx反向代理和正向代理的区别，为什么要使用反向代理


## 16. 开发中是否遇到测试环境和生产环境不一致的问题，如何解决的


## 17. 一条SQL执行的很慢，如何优化，有哪些步骤


## 18. 什么情况下会导致索引失效


## 19. mysql什么情况下会分表，分表的原则是什么
* 

## 20. 什么是聚簇索引
* 聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针

## 21. 数据库问存储过程，游标

## 22. spring注入，注解，原理
## 23. 数据结构，操作系统
## 24. 拦截器和过滤器区别
## 25. 建表的三个范式